<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    macros: {
      oiint: "{\\mathchoice{\\mkern-18mu\\iint}{\\mkern-12mu\\iint}{\\mkern-13mu\\iint}{\\mkern-12mu\\iint}}"
    }
  }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

### 1.5 查找结构实现

**有序表与分块表**

**有序表**: 关键字有序排列，支持二分查找

**分块有序表**:
* 块内无序，块间有序
* 索引表：记录每块最大关键字和起始地址
* 查找：先查索引表，再在块内顺序查找

**跳表（Skip List）**:
* 多层索引结构，类似多级索引
* 查找、插入、删除：平均$O(\log n)$
* 空间复杂度：$O(n)$

**二叉搜索树家族**

**二叉搜索树（BST）**:
* 左子树 < 根 < 右子树
* 中序遍历得到有序序列

**平衡二叉树（AVL）**:
* 平衡因子：$|h_L-h_R|\leq 1$
* 四种旋转：LL, RR, LR, RL

**红黑树**:
1. 结点红或黑
2. 根黑，叶(NIL)黑
3. 红结点的子结点黑
4. 从任一结点到叶子的路径包含相同黑结点数

**B树家族**

**m路查找树**:
* 每个结点最多m棵子树，m-1个关键字
* $K_1<K_2<\dots<K_{m-1}$
* 子树指针：$P_0,P_1,\dots,P_{m-1}$

**m阶B树性质**:
1. 根至少2棵子树（除非为叶）
2. 非叶结点：$\lceil m/2\rceil$到$m$棵子树
3. 所有叶在同一层
4. 关键字数：$\lceil m/2\rceil-1$到$m-1$

**B+树与B树区别**:
* B+树：非叶结点只存索引，数据在叶，叶结点链表连接
* B树：所有结点都存数据

**键树（Trie树）**:
* 关键字由字符构成
* 从根到叶路径表示关键字
* 压缩存储：合并单分支路径

**哈希表实现**

**链地址法**:
```c
typedef struct HashNode {
    KeyType key;
    ValueType value;
    struct HashNode *next;
} HashNode;
```

**开放定址法**:
* 线性探测：$h_i(k)=(h(k)+i)\mod m$
* 二次探测：$h_i(k)=(h(k)+c_1i+c_2i^2)\mod m$
* 双重散列：$h_i(k)=(h_1(k)+ih_2(k))\mod m$

**基桶与溢出桶**:
* 基桶：主存储区，固定大小
* 溢出桶：基桶满时使用，链式连接
* 装填因子：$\alpha=n/m$，影响性能

**哈希函数设计**:
* 除留余数法：$h(k)=k\mod p$
* 平方取中法：$k^2$取中间几位
* 折叠法：分割相加
* 数字分析法：取分布均匀的位

**索引与倒排表**

**索引结构分类**:
* 稠密索引：每个记录都有索引项
* 稀疏索引：一组记录共享索引项
* 主索引：主键上的索引
* 辅助索引：非主键上的索引
* 多级索引：索引的索引

**倒排表（Inverted Index）**:
* 词典：所有单词有序集合
* 倒排列表：$\text{单词}\rightarrow\{\text{文档ID}_1,\text{文档ID}_2,\dots\}$
* 应用：搜索引擎全文检索