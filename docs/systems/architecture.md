<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    macros: {
      oiint: "{\\mathchoice{\\mkern-18mu\\iint}{\\mkern-12mu\\iint}{\\mkern-13mu\\iint}{\\mkern-12mu\\iint}}"
    }
  }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>



# 计算机组成原理

## 一、计算机系统概述

### 1.1 性能指标与冯诺伊曼结构

**计算机性能指标**

**存储容量**:

* 主存容量：$2^n \times m$（n为地址线数，m为数据线位数）

* 辅存容量：字节、KB、MB、GB、TB为单位

* 容量单位：1B=8bit, 1KB=1024B, 1MB=1024KB, 1GB=1024MB

**运算速度指标**:

* **MIPS**（Million Instructions Per Second）：每秒百万条指令

  $\text{MIPS} = \frac{\text{指令条数}}{\text{执行时间} \times 10^6} = \frac{f}{CPI \times 10^6}$

* **FLOPS**（Floating-point Operations Per Second）：每秒浮点运算次数

  $\text{FLOPS} = \frac{\text{浮点运算次数}}{\text{执行时间}}$

* **CPI**（Cycles Per Instruction）：每条指令平均时钟周期数

  $\text{CPI} = \frac{\sum_{i=1}^n (IC_i \times CPI_i)}{IC} = \frac{\text{总时钟周期数}}{\text{总指令数}}$

* **CPU时间**：$\text{CPU时间} = \frac{\text{指令数} \times \text{CPI}}{\text{时钟频率}}$

**字长概念**:

* **机器字长**：CPU一次能处理的二进制位数

* **存储字长**：存储单元存储的二进制位数

* **指令字长**：指令包含的二进制位数

* 关系：指令字长通常是存储字长的整数倍

**冯诺伊曼结构（2009）**

**五大组成部分**：

1. **运算器**（ALU）：算术逻辑运算

2. **控制器**（CU）：指令控制，产生控制信号

3. **存储器**：存储程序和数据

4. **输入设备**：输入信息

5. **输出设备**：输出结果


**核心思想**：

* 存储程序：程序和数据同等对待，都存放在存储器中

* 程序控制：按地址顺序执行指令

* 二进制表示：指令和数据都用二进制表示

**现代计算机改进**：

* 以存储器为中心（原以运算器为中心）

* 引入Cache层次

* 流水线、多核等并行技术

### 1.2 数据表示与运算

**数值编码系统**

**原码表示**：$[x]_{\text{原}} = \begin{cases}
   x & 0 \leq x < 2^{n-1} \\
   2^{n-1} - x & -2^{n-1} < x \leq 0
\end{cases}$

* 范围：$-(2^{n-1}-1) \sim +(2^{n-1}-1)$

* 0的表示：$[+0]_{\text{原}}=000\cdots0$，$[-0]_{\text{原}}=100\cdots0$

**反码表示**：$[x]_{\text{反}} = \begin{cases}
   x & x \geq 0 \\
   (2^n - 1) + x & x < 0
\end{cases}$

* 负数：符号位不变，数值位取反

**补码表示（最常用）**：$[x]_{\text{补}} = \begin{cases}
   x & 0 \leq x < 2^{n-1} \\
   2^n + x & -2^{n-1} \leq x < 0
\end{cases}$

* 范围：$-2^{n-1} \sim +(2^{n-1}-1)$

* 0的唯一表示：$000\cdots0$

* 补码的补码等于原码

**移码表示（阶码用）**：$[x]_{\text{移}} = 2^{n-1} + x$，$-2^{n-1} \leq x < 2^{n-1}$

* 特点：真值增加一个偏移量$2^{n-1}$

* 便于比较大小：按无符号数比较即可

**定点数运算**

**补码加减法**（2021）：

* 公式：$[x+y]_{\text{补}} = [x]_{\text{补}} + [y]_{\text{补}}$（mod $2^n$）

* $[x-y]_{\text{补}} = [x]_{\text{补}} + [-y]_{\text{补}}$

* 溢出判断：

  1. 双符号位法：$S_{s1}S_{s2}=00$（正），$11$（负），$01$（正溢），$10$（负溢）

  2. 单符号位法：$C_s \oplus C_1=1$溢出（$C_s$符号位进位，$C_1$最高数值位进位）

**补码加减运算器设计**：
```python
def 补码加减运算(A, B, SUB):
    # SUB=0: 加法，SUB=1: 减法
    B_prime = B ^ SUB  # SUB控制求反
    C_0 = SUB  # 末位加1（减法时）
    Sum = A + B_prime + C_0
    OF = C_s ^ C_1  # 溢出判断
    return (Sum, OF)
```
**复杂度**：$O(1)$，硬件实现

**阵列乘法器**（2020）：

* 并行乘法，加速乘法运算

* 基本单元：与门和全加器

* $n \times n$位乘法需要$n(n-1)$个全加器

**定点乘法算法（原码乘法）**：
```python
def 原码乘法(x, y, n):
    P = 0  # 部分积
    X = abs(x)
    Y = abs(y)
    for i in range(1, n+1):
        if Y & 1 == 1:  # Y最低位为1
            P = P + X
        P = P >> 1  # 算术右移
        Y = Y >> 1  # 逻辑右移
    符号位 s = (x < 0) ^ (y < 0)
    return (s, P)
```
**思想**：累加-移位，硬件实现简单

**复杂度**：$O(n)$个时钟周期

**定点除法算法（原码恢复余数法）**：
```python
def 原码除法(x, y, n):
    R = abs(x)
    Q = 0
    for i in range(1, n+1):
        R = R - abs(y)
        if R < 0:
            Q_i = 0
            R = R + abs(y)  # 恢复余数
        else:
            Q_i = 1
        R = R << 1  # 左移
        Q = (Q << 1) | Q_i  # 左移并入商
    符号位 s = (x < 0) ^ (y < 0)
    return (s, Q, R)
```
**思想**：试探减，不够减则恢复

**复杂度**：$O(n)$个时钟周期

**不恢复余数法（加减交替法）**：

* 余数为负时，商0，余数左移后加除数

* 余数为正时，商1，余数左移后减除数

* 减少恢复操作，提高速度

**除法器硬件**（2021-2025）：

* 商寄存器：存储商

* 余数寄存器：存储余数

* 控制逻辑：控制加减和移位

**浮点数运算（2009，2018）**

**IEEE 754标准**：

| 类型 | 总位数 | 符号位 | 阶码位数 | 尾数位数 |
|------|--------|--------|----------|----------|
| 单精度 | 32 | 1 | 8 | 23（隐含1） |
| 双精度 | 64 | 1 | 11 | 52（隐含1） |

阶码用移码表示：$E = e + bias$（bias单精度127，双精度1023）

**浮点数加减运算步骤**：

1. **对阶**：小阶向大阶看齐，尾数右移，阶码增加

2. **尾数加减**：尾数部分进行加减运算

3. **规格化**：

   * 左规：尾数最高位为0时左移，阶码减1

   * 右规：尾数溢出时右移，阶码加1（2015上/下溢处理）

4. **舍入处理**：

   * 0舍1入法

   * 恒置1法

   * 截断法

5. **溢出判断**：阶码溢出

**规格化（2018）**：

* 规格化数：尾数$M$满足$1 \leq |M| < 2$（二进制）

* 左规：$M$左移$k$位，阶码减$k$

* 右规：$M$右移$k$位，阶码加$k$

**尾数舍入（2015）**：

* 就近舍入（四舍五入）

* 朝$+\infty$舍入

* 朝$-\infty$舍入

* 朝0舍入（截断）

**浮点运算器结构**：

* 阶码部件：阶码运算，对阶控制

* 尾数部件：尾数运算，移位器

* 控制逻辑：协调各部件工作