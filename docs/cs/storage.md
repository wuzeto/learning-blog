
<script>
window.MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']],
    displayMath: [['$$', '$$'], ['\\[', '\\]']],
    macros: {
      oiint: "{\\mathchoice{\\mkern-18mu\\iint}{\\mkern-12mu\\iint}{\\mkern-13mu\\iint}{\\mkern-12mu\\iint}}"
    }
  }
};
</script>
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>


# 存储系统

## 二、存储系统

### 2.1 存储器层次与性能

**存储器分类与性能**

**按存取方式分类**：
* **RAM**（随机存取存储器）：
  * SRAM：静态RAM，触发器存储，速度快，功耗大，用于Cache
  * DRAM：动态RAM，电容存储，需刷新，密度高，用于主存
* **ROM**（只读存储器）：
  * 掩膜ROM：厂家写入，不可改
  * PROM：用户一次写入
  * EPROM：紫外线擦除
  * EEPROM：电擦除
  * Flash：闪存，块擦除

**性能指标**：
* **存取时间**$T_a$：启动到完成的时间
* **存取周期**$T_c$：连续两次存取的最小时间间隔，$T_c > T_a$
* **存储器带宽**$B_m$：单位时间传输的数据量
  $B_m = \frac{\text{数据宽度}}{T_c}$

**DRAM刷新（2018）**：
* **刷新方式**：
  * 集中刷新：固定时间集中刷新，有死时间
  * 分散刷新：每周期刷新一行，无死时间但周期加倍
  * 异步刷新：按需刷新，折中方案
* **刷新开销**：刷新时间占存取周期的比例
  $\text{刷新开销} = \frac{\text{刷新时间}}{\text{总时间}}$

**主存组织与交叉存储**

**存储芯片扩展**：
* **位扩展**：增加数据位宽
* **字扩展**：增加存储单元数
* **字位同时扩展**：两者都增加

**四体低位交叉存储（2012）**：
* 将存储体分为4个独立的模块
* 地址分布：体号 = 地址 mod 4
* 优点：提高带宽，支持流水访问
* 访问时间：连续访问不同体可重叠

**多模块存储器**：
* 顺序方式：地址顺序分布在各个模块
* 交叉方式：地址交叉分布在各个模块
* 带宽计算：$B = n \times \frac{W}{T}$（n为模块数）

### 2.2 Cache系统

**Cache基本概念**

**Cache性能指标**（2009）：
* **命中率**$H$：$H = \frac{N_c}{N_c + N_m}$
* **平均访问时间**$T_a$：$T_a = H \times T_c + (1-H) \times T_m$
* **访问效率**$e$：$e = \frac{T_c}{T_a} \times 100\%$

**Cache-主存-外存层次**（2021-2025）：
* Cache：SRAM，ns级，MB级
* 主存：DRAM，100ns级，GB级
* 辅存：磁盘/SSD，ms级，TB级
* 目标：接近Cache速度，接近辅存容量

**地址映射方式**

**直接映射**（2010）：
* 主存块只能映射到Cache固定位置
* Cache行号：$i = j \mod m$（$m$为Cache行数）
* 地址结构：标记 | 行号 | 块内地址
* 优点：硬件简单；缺点：冲突率高

**全相联映射**（2013）：
* 主存块可映射到Cache任意位置
* 地址结构：标记 | 块内地址
* 优点：冲突率低；缺点：比较器复杂，速度慢

**组相联映射**（2009 2路组相联）：
* Cache分组，组内全相联
* 组号：$k = j \mod m$（$m$为组数）
* 地址结构：标记 | 组号 | 块内地址
* n路组相联：每组n个Cache行

**地址结构对比**：

| 映射方式 | 地址划分 | 比较器数量 | 特点 |
|----------|----------|------------|------|
| 直接映射 | 标记|行号|块内地址 | 1 | 简单，易冲突 |
| 全相联 | 标记|块内地址 | Cache行数 | 灵活，复杂 |
| 组相联 | 标记|组号|块内地址 | 每组行数 | 折中方案 |

**替换算法与写策略**

**替换算法**：
* **RAND**：随机替换，简单但性能差
* **FIFO**：先进先出，可能Belady异常
* **LRU**：最近最少使用，性能好，实现复杂
* **OPT**：最优替换，理论最优，不可实现

**写策略**：
* **写直达**（Write-through，2015）：
  * 同时写Cache和主存
  * 优点：数据一致性好
  * 缺点：总线 traffic大
* **写回**（Write-back，2015）：
  * 只写Cache，替换时写回主存
  * 优点：减少写主存次数
  * 缺点：数据不一致，需要脏位

**Cache一致性**：
* 写无效：使其他Cache副本无效
* 写更新：更新所有Cache副本
* 监听协议：总线监听一致性操作
* 目录协议：目录记录副本位置

**Cache中的比较器**（2021-2025）：
* 相联存储器实现
* 并行比较，速度关键
* 组相联需要多个比较器

**Cache优化技术**

**多级Cache**：
* L1 Cache：分离的指令Cache和数据Cache（2010）
* L2 Cache：统一Cache
* L3 Cache：共享Cache

**旁路转发**（Bypassing，2012）：
* 将ALU结果直接转发给需要它的指令
* 减少数据冒险的停顿

**预取技术**：
* 硬件预取：根据访问模式预测
* 软件预取：编译器插入预取指令

**非阻塞Cache**：
* 支持多个未完成的Cache缺失
* 提高Cache利用率

### 2.3 虚拟存储器

**虚拟存储概念**

**基本思想**：
* 程序分页/段装入内存
* 部分在内存，部分在外存
* 按需调入，页面置换

**虚地址与物理地址**（2011）：
* 虚地址（逻辑地址）：程序使用的地址
* 物理地址：实际内存地址
* 地址转换：MMU（内存管理单元）完成

**地址转换过程**：
```python
def 地址转换(virtual_addr):
    vpn = virtual_addr >> page_size  # 虚页号
    offset = virtual_addr & (page_size - 1)  # 页内偏移
    pfn = 查页表(vpn)  # 页框号
    if 页表项有效位 == 0:
        缺页中断处理()
    physical_addr = (pfn << page_size) | offset
    return physical_addr
```
**思想**：页表映射虚页到页框
**复杂度**：$O(1)$（有TLB时）

**页表项结构**：
* 页框号：物理页号
* 有效位：是否在内存
* 访问位：是否被访问过（用于置换）
* 修改位：是否被修改过（决定写回）
* 保护位：读/写/执行权限

**页式存储管理（2014）**

**单级页表问题**：
* 页表过大：$2^{20}$个页表项（4GB内存，4KB页）
* 页表需连续存储

**二级页表**（2010）：
* 页目录 + 页表
* 虚地址：页目录索引 | 页表索引 | 页内偏移
* 优点：页表可离散存放，部分不必常驻内存

**多级页表**：
* 进一步减少页表占用空间
* 增加地址转换时间

**倒置页表**：
* 按物理页号组织
* 项数=物理页数，节省空间
* 查找需要哈希或相联存储器

**段页式存储**：
* 结合分段和分页优点
* 先分段，段内再分页
* 地址：段号 | 段内页号 | 页内偏移

**TLB与缺页处理**

**TLB（快表）**：
* 缓存最近使用的页表项
* 相联存储器实现，并行查找
* 提高地址转换速度

**缺页率与有效访问时间**：
* 缺页率$p$：$p = \frac{\text{缺页次数}}{\text{访问次数}}$
* 有效访问时间$T_e$：
  $T_e = (1-p) \times T_a + p \times T_f$
  其中$T_a$为访问时间，$T_f$为缺页处理时间

**缺页处理过程**（2019页故障）：
1. 陷入操作系统，保存现场
2. 检查访问合法性
3. 寻找空闲页框，若无则页面置换
4. 从磁盘读入所需页
5. 修改页表，设置有效位
6. 恢复现场，重新执行指令

**页面置换算法**：
* **OPT**：淘汰未来最长时间不使用
* **FIFO**：先进先出，可能Belady异常
* **LRU**：最近最少使用，实现复杂
* **CLOCK**：时钟算法，近似LRU

**存储保护**

**访问越权**（2021-2025）：
* 越界访问：地址超出程序空间
* 越权访问：违反保护权限（读/写/执行）
* 处理：存储保护异常，陷入操作系统

**保护机制**：
* 界限寄存器：基址和限长寄存器
* 页表保护位：每页的读/写/执行权限
* 段保护：段描述符中的权限位