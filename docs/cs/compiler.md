


# 形式语言与自动机核心知识点笔记
## 引言
- 本课程知识点具有“点多、碎”的特点，本次梳理聚焦核心思路，部分概念会快速带过，如有疑问可随时打断交流。
- 考试重点分布：
  - 概念类（判断题）：以PPT内容为主；
  - 算法类（简答题）：以PPT内容为主；
  - 证明题：重点关注课上证明思路，辅以作业中的证明题练习；
  - 构造题：参考作业答案和课上例题；
  - 细节考点：欢迎补充交流。
- 备注：第4章部分算法可适当弱化关注。

## 第一讲 基础概念
### 1. 字母表
字母表是一个非空的有限集合，通常用符号$\sum$表示，集合中的元素称为“字符”或“符号”。例如，二进制字母表$\sum = \{0,1\}$、英文字母表$\sum = \{a,b,c,...,z\}$。字母表是构成字符串和语言的基本单位，所有字符串的字符都必须来源于对应的字母表。

### 2. 运算（字母表与字符串的基本运算）
- 字符串连接：设$x$和$y$是两个字符串，连接运算$xy$表示将$y$的字符依次接在$x$的字符之后形成的新字符串。例如，$x = "ab"$，$y = "cd"`，则$xy = "abcd"`。
- 字符串闭包：
  - 正闭包$x^+$：表示由字符串$x$经过1次或多次连接形成的所有字符串集合，即$x^+ = x \cup xx \cup xxx \cup ...$；
  - Kleene闭包$x^*$：表示由字符串$x$经过0次或多次连接形成的所有字符串集合（包含空串$\varepsilon$），即$x^* = \{\varepsilon\} \cup x \cup xx \cup xxx \cup ...$。
- 字母表的乘积：设$\sum_1$和$\sum_2$是两个字母表，乘积运算$\sum_1 \times \sum_2 = \{(a,b) | a \in \sum_1, b \in \sum_2\}$，表示所有由$\sum_1$的字符和$\sum_2$的字符组成的有序对集合。

### 3. 语言
语言是字母表$\sum$上所有字符串集合的一个子集，记为$L \subseteq \sum^*$。例如，$\sum = \{0,1\}$时，所有由偶数个0组成的字符串构成的集合$L = \{\varepsilon, 00, 0000, ...\}$就是$\sum$上的一种语言。语言可以通过文法、自动机等方式进行定义和描述。

### 4. 归纳与互归纳
- 归纳法：是证明与自然数相关命题或递归定义对象性质的核心方法，分为基础步和归纳步。基础步证明命题对初始情况（如字符串长度为0、1，推导步数为1等）成立；归纳步假设命题对$n$成立，证明对$n+1$也成立。
- 互归纳：当需要证明多个相互关联的命题同时成立时使用，例如证明文法的推导步数与字符串长度的对应关系、多个集合的包含关系等，通过交替归纳每个命题的成立性来完成证明。

## 第二讲 上下文无关文法（CFG）与上下文无关语言（CFL）
### 1. 核心概念
#### （1）上下文无关文法的定义
上下文无关文法（CFG）的形式化定义为$G = (V, T, P, S)$，其中：
- $V$：非终结符集合（变量集合），元素通常用大写字母表示（如$A,B,S$）；
- $T$：终结符集合，元素通常用小写字母、数字等表示（如$a,b,0,1$），且$V \cap T = \emptyset$；
- $P$：产生式集合，每个产生式形如$A \to \beta$，其中$A \in V$（产生式左部必须是单个非终结符），$\beta \in (V \cup T)^*$（右部可以是终结符、非终结符的任意组合，包括空串$\varepsilon$）；
- $S$：起始符号，$S \in V$，是文法推导的起始点。

#### （2）上下文无关语言（CFL）
由上下文无关文法$G$推导产生的所有终结符字符串的集合，称为$G$定义的上下文无关语言，记为$L(G)$，即$L(G) = \{w \in T^* | S \stackrel{*}{\Rightarrow} w\}$（$\stackrel{*}{\Rightarrow}$表示经过0步或多步推导）。

#### （3）推导与归约
- 推导：从起始符号$S$出发，按照产生式规则逐步替换非终结符，最终得到终结符字符串的过程。例如，$G: S \to AB, A \to a, B \to b$，则推导过程为$S \Rightarrow AB \Rightarrow aB \Rightarrow ab$。
- 最左推导：每次推导时，总是选择字符串中最左侧的非终结符进行替换。
- 最右推导（规范推导）：每次推导时，总是选择字符串中最右侧的非终结符进行替换。
- 归约：推导的逆过程，从终结符字符串出发，按照产生式规则反向替换（将某子串替换为对应的非终结符），最终回到起始符号$S$的过程。

#### （4）语法分析树
语法分析树是推导过程的可视化表示，树的节点满足：
- 根节点为起始符号$S$；
- 内部节点为非终结符，其子女节点对应产生式右部的符号（终结符或非终结符）；
- 叶节点为终结符（或空串），所有叶节点按从左到右的顺序排列，构成文法生成的字符串（称为“果实”）。
- 关系：归约过程对应语法分析树的“剪枝”，推导过程对应“建树”，一棵语法分析树唯一对应一种推导（但可能对应多个不同顺序的推导，如最左、最右推导）。

#### （5）二义文法与语言的固有二义性
- 二义文法：若存在一个字符串$w \in L(G)$，使得$w$对应两棵或多棵不同的语法分析树（或存在两种不同的最左推导/最右推导），则称$G$为二义文法。
- 语言的固有二义性：若不存在任何无二义的上下文无关文法能生成语言$L$，则称$L$是固有二义的上下文无关语言。注意：文法的二义性是文法的属性，而非语言的属性；但部分语言具有固有二义性。

#### （6）消除二义性的方法
- 算符优先级：为文法中的运算符定义优先级和结合性（如乘法优先级高于加法，左结合），通过修改产生式规则避免二义推导。
- 最近嵌套法：针对“悬挂else”等二义性问题，规定else总是与最近的未匹配if结合，通过调整产生式结构实现。

### 2. Chomsky四型语法分类
Chomsky文法分类的核心依据是产生式的形式限制，不同类型文法对应的语言和自动机模型如下：

| 文法类型 | 产生式限制 | 对应的语言 | 等价的自动机模型 |
|----------|------------|------------|------------------|
| 0型文法（无限制文法） | $\alpha \to \beta$，其中$\alpha, \beta \in (V \cup T)^*$，且$\alpha$中至少含一个非终结符 | 0型语言（递归可枚举语言） | 图灵机（Turing Machine） |
| 1型文法（上下文有关文法） | $\alpha \to \beta$，满足$|\alpha| \leq |\beta|$（仅$S \to \varepsilon$例外），且$S$不得出现在任何产生式右部 | 1型语言（上下文有关语言） | 线性有界自动机（Linear Bounded Automaton） |
| 2型文法（上下文无关文法） | $A \to \beta$，其中$A \in V$，$\beta \in (V \cup T)^*$ | 2型语言（上下文无关语言） | 下推自动机（Pushdown Automaton, PDA） |
| 3型文法（正规文法） | 产生式形如$A \to aB$或$A \to a$（右线性），或$A \to Ba$或$A \to a$（左线性），其中$A,B \in V$，$a \in T \cup \{\varepsilon\}$ | 3型语言（正规语言） | 有限状态自动机（Finite Automaton, FA） |

### 3. 典型题目与解题思路
- 设计上下文无关文法：根据语言的结构特点（如括号匹配、回文串、$ww^R$等），定义非终结符和产生式，需注意覆盖极端情况（如空串$\varepsilon$），设计后需双重验证。
- 文法的二义消除：针对二义文法，通过定义优先级、结合性或修改产生式结构，确保每个字符串仅有唯一语法分析树。
- 证明某个文法的语言是某种串集合：采用“双向证明”策略——一方面归纳于字符串长度，证明该集合中的所有串都能被文法推导；另一方面归纳于推导步数，证明文法推导的所有串都属于该集合，必要时使用互归纳。

## 第三讲 正规表达式（RE）
### 1. 核心概念
#### （1）正规表达式的归纳定义
正规表达式（RE）是描述正规语言的形式化工具，基于字母表$\sum$归纳定义：
- 基础情况：$\varepsilon$（空串）、$\phi$（空集）、$a$（$a \in \sum$）都是正规表达式；
- 归纳情况：若$E$和$F$是正规表达式，则：
  - $E + F$（并）：表示$L(E) \cup L(F)$；
  - $EF$（连接）：表示$L(E)L(F) = \{xy | x \in L(E), y \in L(F)\}$；
  - $E^*$（Kleene闭包）：表示$L(E)^* = \{\varepsilon\} \cup L(E) \cup L(E)L(E) \cup ...$；
- 运算优先级：闭包（$^*$）> 连接 > 并（$+$），可通过括号调整优先级。

#### （2）正规语言的定义
由正规表达式定义的语言称为正规语言，即对于正规表达式$E$，其对应的正规语言$L(E)$由上述归纳定义的集合运算确定。正规语言与3型文法、有限状态自动机描述的语言完全等价。

#### （3）正规表达式的代数定律
正规表达式满足一系列代数运算性质，例如：
- 交换律：$E + F = F + E$；
- 结合律：$(E + F) + G = E + (F + G)$，$(EF)G = E(FG)$；
- 分配律：$E(F + G) = EF + EG$，$(F + G)E = FE + GE$；
- 幂等律：$E + E = E$；
- 单位元：$E\varepsilon = \varepsilon E = E$，$E + \phi = E$；
- 零元：$E\phi = \phi E = \phi$。
这些定律可用于正规表达式的化简和等价证明。

### 2. 典型题目与解题思路
- 设计正规表达式：根据语言需求（如“包含子串ab”“以0结尾”“长度为偶数的串”等），利用并、连接、闭包运算组合基础表达式，注意处理极端情况（如是否包含空串$\varepsilon$），善用$\varepsilon + a$（表示可选的$a$）等技巧。
- 证明或否定关于正规表达式的命题：
  - 证明：将命题具体化（代入具体表达式），简单命题可直接验证，复杂命题（含$^*$）可通过归纳法或代数定律化简推导；
  - 否定：构造反例（如特殊串$\varepsilon$、单个字符串等），证明命题不成立。

## 第四讲 有限状态自动机（FA）
### 1. 核心概念
#### （1）有限状态自动机的定义与分类
有限状态自动机（FA）的形式化定义为$A = (Q, \sum, \delta, q_0, F)$，其中：
- $Q$：有限状态集合；
- $\sum$：输入字母表（有限非空）；
- $\delta$：转移函数，不同类型FA的$\delta$定义不同：
  - 确定有限自动机（DFA）：$\delta: Q \times \sum \to Q$，对每个状态$q \in Q$和每个输入字符$a \in \sum$，有且仅有一个转移状态；
  - 非确定有限自动机（NFA）：$\delta: Q \times (\sum \cup \{\varepsilon\}) \to 2^Q$，允许输入$\varepsilon$（空转移），且一个状态对一个输入可转移到多个状态；
  - $\varepsilon$-NFA：NFA的一种特殊形式，明确允许$\varepsilon$转移；
- $q_0$：初始状态，$q_0 \in Q$；
- $F$：终态集合，$F \subseteq Q$。

#### （2）扩充转移函数$\delta'$
为了描述FA经过多步转移后的状态，定义扩充转移函数$\delta'$：
- DFA：$\delta'(q, \varepsilon) = q$（空串转移到自身），$\delta'(q, wa) = \delta(\delta'(q, w), a)$（$w \in \sum^*$，$a \in \sum$）；
- NFA/$\varepsilon$-NFA：$\delta'(q, \varepsilon)$为$q$通过$\varepsilon$边能到达的所有状态（记为$\text{ENCLOSE}(q)$），$\delta'(q, wa) = \text{ENCLOSE}(\bigcup_{p \in \delta'(q, w)} \delta(p, a))$。

#### （3）子集构造法（NFA/$\varepsilon$-NFA 转 DFA）
核心思想：将NFA的状态集合作为DFA的单个状态，消除不确定性，步骤如下：
1. 初始化DFA的初始状态为$\text{ENCLOSE}(q_0)$（NFA初始状态的$\varepsilon$闭包）；
2. 对DFA的每个状态$S$（NFA状态集合）和每个输入字符$a \in \sum$，计算$S_a = \text{ENCLOSE}(\bigcup_{q \in S} \delta(q, a))$，作为$S$在输入$a$下的转移状态；
3. 重复步骤2，直到没有新的DFA状态生成；
4. DFA的终态集合为所有包含NFA终态的DFA状态。
修改的子集构造法：直接基于$\text{ENCLOSE}(q)$进行状态转移计算，简化$\varepsilon$闭包的处理流程。

#### （4）DFA最小化
DFA最小化是指构造与原DFA等价（接受相同语言）且状态数最少的DFA，核心是合并“等价状态”。
- 状态等价：两个状态$p$和$q$等价，当且仅当对于所有输入字符串$w$，$\delta'(p, w) \in F$等价于$\delta'(q, w) \in F$（即对所有$w$，两状态的接受性一致）；
- 状态可区别：若存在字符串$w$使得$\delta'(p, w)$和$\delta'(q, w)$一个是终态、一个是非终态，则$p$和$q$可区别；
- 填表算法（核心步骤）：
  1. 预处理：删除DFA中的不可达状态（从初始状态无法到达的状态）；
  2. 初始化表格：对所有状态对$(p, q)$，若$p \in F$且$q \notin F$（或反之），标记为“可区别”；
  3. 迭代标记：对未标记的状态对$(p, q)$，若存在输入字符$a$，使得$\delta(p, a)$和$\delta(q, a)$已标记为“可区别”，则标记$(p, q)$为“可区别”；
  4. 合并等价状态：将未标记的状态对（等价状态）合并为一个新状态，重构转移函数，得到最小DFA。

### 2. 典型题目与解题思路
- NFA构造DFA：使用子集构造法，按“状态集合的$\varepsilon$闭包→转移→新状态集合”的流程逐步推导，注意处理空集状态（无转移的状态）；
- DFA最小化：严格遵循“删不可达状态→填表标记可区别状态→合并等价状态→重构DFA”的步骤，确保每个状态和每个字符都有且仅有一条出边（满足DFA定义）；
- 特殊场景：若直接构造DFA困难，可先设计对应的正规表达式，再通过Thompson构造法转换为NFA，最后子集构造为DFA。

## 第五讲 正规表达式与有限自动机的等价性
### 1. 核心转换方法
#### （1）正规表达式→$\varepsilon$-NFA（Thompson构造法）
基于正规表达式的归纳定义构造等价的$\varepsilon$-NFA，步骤如下：
- 基础情况：
  1. 对于$\varepsilon$：构造仅有初始状态和终态，且两状态间有一条$\varepsilon$边的$\varepsilon$-NFA；
  2. 对于$\phi$：构造仅有初始状态和终态，且无任何转移边的$\varepsilon$-NFA；
  3. 对于$a \in \sum$：构造仅有初始状态和终态，且两状态间有一条标记为$a$的边的$\varepsilon$-NFA；
- 归纳情况：
  1. 并运算$E + F$：构造新初始状态和新终态，新初始状态通过$\varepsilon$边分别连接$E$和$F$的初始状态，$E$和$F$的终态通过$\varepsilon$边分别连接新终态；
  2. 连接运算$EF$：将$E$的终态与$F$的初始状态合并，以$E$的初始状态为新初始状态，$F$的终态为新终态；
  3. 闭包运算$E^*$：构造新初始状态和新终态，新初始状态通过$\varepsilon$边连接$E$的初始状态和新终态，$E$的终态通过$\varepsilon$边连接$E$的初始状态和新终态。

#### （2）DFA→正规表达式（路径迭代法/状态消去法）
路径迭代法的核心思想是逐步允许经过更高编号的状态，迭代计算状态间的正规表达式，步骤如下：
1. 给DFA的状态编号为$1,2,...,n$，初始状态为1；
2. 定义$R_{ij}^{(k)}$：表示从状态$i$到状态$j$，且路径上除$i$和$j$外所有状态编号不大于$k$的字符串对应的正规表达式；
3. 基础步（$k=0$）：
   - 若$i \neq j$：无直接边则$R_{ij}^{(0)} = \phi$；有$m$条标记为$a_1,...,a_m$的直接边则$R_{ij}^{(0)} = a_1 + ... + a_m$；
   - 若$i = j$：无自环则$R_{ii}^{(0)} = \varepsilon$；有$m$条标记为$a_1,...,a_m$的自环则$R_{ii}^{(0)} = \varepsilon + a_1 + ... + a_m$；
4. 归纳步（$k \geq 1$）：$R_{ij}^{(k)} = R_{ij}^{(k-1)} + R_{ik}^{(k-1)} (R_{kk}^{(k-1)})^* R_{kj}^{(k-1)}$（路径要么不经过$k$，要么经过$k$若干次）；
5. 最终结果：所有终态$j$对应的$R_{1j}^{(n)}$的并，即为DFA对应的正规表达式。

### 2. 典型题目
- 正规表达式转$\varepsilon$-NFA：严格遵循Thompson构造法的归纳步骤，确保$\varepsilon$边和转移方向正确；
- DFA转正规表达式：选择路径迭代法或状态消去法，状态消去法更直观（逐步删除非初始、非终态的状态，合并转移边对应的表达式），最终将所有终态对应的表达式求和。

## 第六讲 正规语言的性质与Pumping引理
### 1. 核心概念
#### （1）正规语言的Pumping引理
Pumping引理是证明某语言不是正规语言的核心工具，其本质是利用正规语言对应的DFA状态数有限，长串必然会重复经过某个状态（形成回路）。

**形式化表述**：
存在正整数$n$（称为泵长度，通常取DFA的状态数），使得对于任意$w \in L$且$|w| \geq n$，存在$x,y,z \in \sum^*$满足：
1. $w = xyz$；
2. $y \neq \varepsilon$（$y$是非空串，对应回路）；
3. $|xy| \leq n$（回路出现在串的前$n$个字符中）；
4. 对所有$k \geq 0$，$xy^k z \in L$（重复或删除回路对应的串$y$，结果仍在语言中）。

**否定形式**（用于证明非正规语言）：
对任意正整数$n$，存在$w \in L$且$|w| \geq n$，使得对所有$x,y,z \in \sum^*$满足$w = xyz$、$y \neq \varepsilon$、$|xy| \leq n$时，存在$k \geq 0$使得$xy^k z \notin L$。

#### （2）正规语言的封闭运算
正规语言对以下运算封闭（运算后仍为正规语言）：
- 基本运算：并（$L1 \cup L2$）、连接（$L1L2$）、闭包（$L^*$）；
- 补运算：$\overline{L} = \sum^* \setminus L$（将DFA的终态改为非终态，非终态改为终态即可）；
- 交运算：$L1 \cap L2 = \overline{\overline{L1} \cup \overline{L2}}$（由补运算和并运算的封闭性推导）；
- 反向运算：$L^R = \{w^R | w \in L\}$（$w^R$是$w$的逆序串，反转DFA的转移边，初始状态改为终态，终态改为初始状态）；
- 同态运算：设$h: \sum \to \Gamma^*$是同态映射，则$h(L) = \{h(w) | w \in L\}$；
- 逆同态运算：$h^{-1}(L) = \{w \in \sum^* | h(w) \in L\}$。

#### （3）正规语言的判定算法
- 语言是否为空：检查DFA是否存在从初始状态到终态的可达路径；
- 语言是否含某特殊字符串$w$：模拟DFA对$w$的转移，看是否能到达终态；
- 两个正规语言是否相等：构造$L1 \triangle L2 = (L1 \setminus L2) \cup (L2 \setminus L1)$，判定其是否为空（为空则$L1 = L2$）。

### 2. 典型题目
- 证明某语言不是正规语言：使用Pumping引理的否定形式，步骤为：
  1. 假设$L$是正规语言，取任意$n \geq 1$；
  2. 构造$w \in L$且$|w| \geq n$（通常构造$w = a^n b^n$、$w = n$的二进制表示等，利用语言的结构特点）；
  3. 对任意满足$w = xyz$、$y \neq \varepsilon$、$|xy| \leq n$的$x,y,z$，分析$y$的结构（如仅含$a$、仅含$b$或混合）；
  4. 选择合适的$k$（如$k=0$或$k=2$），证明$xy^k z \notin L$，矛盾，故$L$不是正规语言。
- 证明正规语言的封闭运算：利用正规语言的等价模型（DFA、RE），通过构造对应的DFA或RE来证明运算结果仍为正规语言。

## 第七讲 下推自动机（PDA）
### 1. 核心概念
#### （1）下推自动机的定义
下推自动机（PDA）是识别上下文无关语言的自动机模型，在FA的基础上增加了一个无限栈（用于存储非终结符或标记），形式化定义为$P = (Q, \sum, \Gamma, \delta, q_0, Z_0, F)$，其中：
- $Q$：有限状态集合；
- $\sum$：输入字母表；
- $\Gamma$：栈字母表；
- $\delta$：转移函数，$\delta: Q \times (\sum \cup \{\varepsilon\}) \times \Gamma \to 2^{Q \times \Gamma^*}$（输入字符、栈顶符号决定转移后的状态和栈操作）；
- $q_0$：初始状态；
- $Z_0$：初始栈顶符号；
- $F$：终态集合（可选，因PDA有两种接受方式）。

#### （2）PDA的格局与接受方式
- 格局（ID）：用$(q, w, \gamma)$表示，其中$q \in Q$（当前状态），$w \in \sum^*$（剩余输入串），$\gamma \in \Gamma^*$（当前栈内容，最左侧为栈顶）；
- 终态接受（$L(P)$）：若存在格局转移$(q_0, w, Z_0) \stackrel{*}{\Rightarrow} (q, \varepsilon, \gamma)$且$q \in F$，则$w \in L(P)$；
- 空栈接受（$N(P)$）：若存在格局转移$(q_0, w, Z_0) \stackrel{*}{\Rightarrow} (q, \varepsilon, \varepsilon)$，则$w \in N(P)$；
- 两种接受方式的转化：
  - 终态接受转空栈接受：增加新初始状态，压入新栈顶符号，终态弹出所有栈符号；
  - 空栈接受转终态接受：增加新终态，当栈为空时转移到新终态。

### 2. 典型题目与解题思路
- 设计PDA：根据语言的上下文无关特性（如括号匹配、$ww^R$、$a^n b^n$等），选择终态接受或空栈接受（需明确说明），利用栈存储关键信息（如$a$的个数、非终结符）；若直接设计困难，可先设计对应的CFG，再通过CFG转PDA的方法构造。

## 第八讲 CFG与PDA的等价性
### 1. 核心转换方法
#### （1）CFG→PDA（空栈接受）
设CFG $G = (V, T, P, S)$，构造等价的PDA $E = (\{q\}, T, V \cup T, \delta, q, S)$，转移函数$\delta$定义如下：
1. 对每个产生式$A \to \beta \in P$，添加转移$\delta(q, \varepsilon, A) = \{(q, \beta)\}$（栈顶为非终结符$A$时，用$\beta$替换$A$，无需输入）；
2. 对每个终结符$a \in T$，添加转移$\delta(q, a, a) = \{(q, \varepsilon)\}$（输入字符$a$与栈顶$a$匹配，弹出栈顶）。
- 接受逻辑：从初始栈顶$S$出发，通过产生式替换非终结符，匹配所有输入字符后栈为空，即接受该串。

#### （2）PDA→CFG（复杂）
设PDA $E = (Q, \sum, \Gamma, \delta, q_0, Z_0, F)$，构造等价的CFG $G = (V, \sum, P, S)$，其中：
- $V = \{S\} \cup \{[pXq] | p, q \in Q, X \in \Gamma\}$（$[pXq]$表示“从状态$p$出发，栈顶为$X$，处理某串后到达状态$q$且栈为空”）；
- 产生式集合$P$：
  1. 对每个$p \in Q$，添加$S \to [q_0 Z_0 p]$（初始符号对应从初始状态、初始栈顶出发，到达任意状态$p$）；
  2. 若$\delta(p, a, X) \ni (q, X_1 X_2 ... X_k)$（$a \in \sum \cup \{\varepsilon\}$），则添加产生式$[pXp_k] \to a [qX_1 p_1] [p_1 X_2 p_2] ... [p_{k-1} X_k p_k]$（$p_1,...,p_k$为中间状态，递归处理栈中符号）。

### 2. 典型题目
- CFG转PDA：直接应用上述构造方法，步骤简单，无需设计复杂状态（仅需一个状态）；
- PDA转CFG：步骤繁琐，需准确定义非终结符$[pXq]$和产生式，通常优先选择“设计CFG→转PDA”的思路，可操作性更强。

## 第九讲 确定型下推自动机（DPDA）
### 1. 核心概念
#### （1）DPDA的定义
确定型下推自动机（DPDA）是PDA的特例，满足以下确定性条件：
- 对任意状态$q \in Q$、输入字符$a \in \sum$、栈顶符号$X \in \Gamma$，$\delta(q, a, X)$和$\delta(q, \varepsilon, X)$中最多有一个非空（若存在$a$转移，则无$\varepsilon$转移）；
- 若$\delta(q, a, X)$非空，则其仅含一个元素（转移状态和栈操作唯一）。

#### （2）DPDA的特性
- 计算能力：DPDA强于DFA（能识别部分非正规语言，如$a^n b^n$），但弱于非确定型PDA（不能识别所有上下文无关语言，如$a^n b^n c^n$）；
- 接受方式：空栈接受的DPDA识别的语言具有“前缀性质”（若$w$被接受，则$w$的任何前缀都不被接受）；空栈接受和终态接受的DPDA不等价（部分语言可由终态接受DPDA识别，但不能由空栈接受DPDA识别）；
- 典型例子：$ww^R$（回文串）、$wcw^R$（中心为$c$的回文串）可由DPDA识别。

### 2. 典型题目
- 设计DPDA：严格遵循确定性条件，避免$\varepsilon$转移与字符转移冲突，明确接受方式（空栈或终态），可参考CFG转PDA的思路，确保每一步转移唯一。

## 第十讲 CFG的标准化与化简
### 1. 核心概念与步骤
CFG的标准化（如Chomsky范式）和化简（消除无用符号、$\varepsilon$产生式、Unit产生式）是后续算法（如CYK算法）的基础，步骤顺序不可颠倒：

#### （1）消除$\varepsilon$产生式
$\varepsilon$产生式是形如$A \to \varepsilon$的产生式（$A \in V$），消除步骤：
1. 找出所有能推导$\varepsilon$的非终结符（称为 nullable 符号）：基础步（$A \to \varepsilon$则$A$是nullable），归纳步（若产生式右部所有符号都是nullable，则左部非终结符是nullable）；
2. 对每个产生式$A \to \alpha_1 \alpha_2 ... \alpha_k$，生成所有可能的“非$\varepsilon$变体”（删除部分或全部nullable符号，至少保留一个符号，避免生成$\varepsilon$）；
3. 若起始符号$S$是nullable，添加新起始符号$S'$和产生式$S' \to S | \varepsilon$。

#### （2）消除Unit产生式
Unit产生式是形如$A \to B$的产生式（$A, B \in V$），消除步骤：
1. 对每个非终结符$A$，找出所有通过Unit产生式可达的非终结符集合$U(A)$（包括$A$自身）；
2. 替换所有Unit产生式：对每个$B \in U(A)$，将$B$的非Unit产生式$B \to \alpha$替换为$A \to \alpha$；
3. 删除所有Unit产生式。

#### （3）消除无用符号
无用符号是指“不可达符号”（从起始符号$S$无法到达）或“不可生成符号”（无法推导为终结符字符串），消除步骤：
1. 消除不可生成符号：找出所有可生成符号（基础步：终结符是可生成的；归纳步：若产生式右部所有符号都是可生成的，则左部非终结符是可生成的），删除含不可生成符号的产生式和不可生成符号；
2. 消除不可达符号：找出所有可达符号（基础步：$S$是可达的；归纳步：若$A$是可达的且$A \to \alpha$，则$\alpha$中所有非终结符是可达的），删除含不可达符号的产生式和不可达符号。

#### （4）转换为Chomsky范式（CNF）
Chomsky范式要求所有产生式满足以下形式之一：
- $A \to BC$（右部为两个非终结符）；
- $A \to a$（右部为单个终结符）；
- $S \to \varepsilon$（仅当$S$是起始符号且无其他产生式时）。
转换步骤：
1. 完成上述“消除$\varepsilon$产生式、Unit产生式、无用符号”；
2. 对每个产生式$A \to \alpha$（$\alpha$长度$\geq 3$），引入新非终结符分解右部，例如$A \to aBC$分解为$A \to X_1 BC$、$X_1 \to a$；$A \to BCD$分解为$A \to X_2 D$、$X_2 \to BC$。

### 2. 典型题目
- CFG的标准化与化简：严格遵循“消除$\varepsilon$产生式→消除Unit产生式→消除无用符号→转换为Chomsky范式”的顺序，每一步后验证文法正确性，确保无遗漏或错误替换。

## 第十一讲 上下文无关语言的性质与CYK算法
### 1. 核心概念
#### （1）上下文无关语言的Pumping引理
用于证明某语言不是上下文无关语言，形式化表述：
存在正整数$n$，使得对于任意$z \in L$且$|z| \geq n$，存在$u, v, w, x, y \in \sum^*$满足：
1. $z = uvwxy$；
2. $vx \neq \varepsilon$（$v$或$x$非空）；
3. $|vwx| \leq n$（泵部分长度不超过$n$）；
4. 对所有$k \geq 0$，$uv^k w x^k y \in L$。
证明非上下文无关语言的思路与正规语言的Pumping引理类似，构造矛盾串并分析$v$和$x$的结构。

#### （2）CYK算法
CYK算法是判断一个字符串是否属于某上下文无关语言的多项式时间算法，前提是文法已转换为Chomsky范式，步骤如下：
1. 设字符串$w = a_1 a_2 ... a_n$，文法$G = (V, T, P, S)$；
2. 构造$(n \times n)$表格$T$，$T[i][j]$表示能推导子串$a_i ... a_j$的非终结符集合；
3. 初始化（$j = i$，子串长度为1）：$T[i][i] = \{A \in V | A \to a_i \in P\}$；
4. 迭代（子串长度$l = 2$到$n$）：对每个子串$a_i ... a_j$（$j = i + l - 1$），枚举分割点$k$（$i \leq k < j$），若存在$A \to BC$且$B \in T[i][k]$、$C \in T[k+1][j]$，则将$A$加入$T[i][j]$；
5. 结果：若$S \in T[1][n]$，则$w \in L(G)$，否则不属于。

#### （3）上下文无关语言的封闭运算
上下文无关语言对以下运算封闭：并、连接、闭包、替换、同态、反向、与正规语言的交；对补运算、交运算不封闭。

#### （4）不可判定问题
上下文无关语言的部分问题无法通过算法判定（即不存在通用图灵机解决），包括：
- CFG是否无二义；
- CFG是否固有二义；
- 两个CFG的语言是否相交（为空）；
- 两个CFG的语言是否相等；
- CFG的语言是否为$\sum^*$。

### 2. 典型题目
- 证明某语言不是上下文无关语言：应用上下文无关语言的Pumping引理，构造合适的矛盾串（如$a^n b^n c^n$）；
- CYK算法应用：先将CFG转换为Chomsky范式，再按表格填充步骤逐步计算，最终判断字符串是否被接受；
- 封闭运算证明：利用上下文无关语言的等价模型（CFG、PDA），构造对应的文法或自动机证明运算结果仍为上下文无关语言。

## 第十二讲 图灵机（TM）
### 1. 核心概念
#### （1）基本图灵机的定义
图灵机是计算模型的终极形式，能模拟所有可计算过程，形式化定义为$M = (Q, \sum, \Gamma, \delta, q_0, B, F)$，其中：
- $Q$：有限状态集合；
- $\sum$：输入字母表（$\sum \subseteq \Gamma \setminus \{B\}$）；
- $\Gamma$：带字母表（包含空白符$B$）；
- $\delta$：转移函数，$\delta: Q \times \Gamma \to Q \times \Gamma \times \{L, R\}$（状态、当前带符号→新状态、新带符号、读写头移动方向（左$L$或右$R$））；
- $q_0$：初始状态；
- $B$：空白符；
- $F$：终态集合（接受状态）。

#### （2）格局与停机
- 格局：用$(q, \alpha, \beta)$表示，其中$q \in Q$（当前状态），$\alpha \beta$是当前带内容（$\alpha$是读写头左侧的字符串，$\beta$是读写头右侧的字符串，读写头指向$\beta$的第一个字符）；
- 停机：当图灵机进入终态（$q \in F$）或转移函数无定义时，停机；若停机在终态，则接受输入串；否则拒绝。

#### （3）递归语言与递归可枚举语言
- 递归可枚举语言（r.e.语言）：存在图灵机接受该语言（停机在终态当且仅当输入串属于语言，拒绝时可能不停机）；
- 递归语言：存在图灵机判定该语言（对所有输入串都停机，接受或拒绝），递归语言是递归可枚举语言的子集。

#### （4）扩展的图灵机
扩展图灵机与基本图灵机计算能力等价（可相互模拟），常见扩展形式：
- 多带图灵机：多个读写头和纸带，初始输入在第一带，其他带为空白，可通过“多道模拟”（将多个带的内容编码到一个带的不同轨道）转化为单带图灵机；
- 非确定图灵机：转移函数$\delta: Q \times \Gamma \to 2^{Q \times \Gamma \times \{L, R\}}$，有多个可能的下一步转移，接受输入当且仅当存在一条转移路径到达终态；
- 受限图灵机：如半无穷带图灵机（纸带仅右侧无限）、多栈机、计数器机（栈字母表仅含一个非空白符），除单计数器机外，其余均与基本图灵机等价。

#### （5）编程技巧
- 存储区状态：将部分信息编码到状态中，减少带操作；
- 多道：将纸带分为多个轨道，分别存储不同类型的信息；
- 子例程：将复杂功能（如加法、比较）封装为子例程，通过状态转移实现调用和返回。

### 2. 典型题目
- 构造图灵机及其变种：根据语言需求（如“接受所有回文串”“计算两数之和”），设计状态转移和带操作，明确读写头移动方向和带符号修改规则；
- 概念判断：理解递归语言与递归可枚举语言的区别、扩展图灵机的等价性等核心概念。

## 第十三讲 可判定性与计算复杂性
### 1. 核心概念
#### （1）可判定性相关
- 图灵机的二进制编码：将图灵机的状态、转移函数等信息编码为二进制串，每个图灵机对应唯一的编码（称为“哥德尔编码”）；
- 对角语言：$L_d = \{<M> | M$是图灵机，且$<M> \notin L(M)\}$（$<M>$表示$M$的编码），$L_d$不是递归可枚举语言（证明采用对角化方法）；
- 语言的封闭性：递归语言对补运算封闭，递归可枚举语言对补运算不封闭；
- 通用语言：$L_u = \{<M, w> | M$是图灵机，$w \in L(M)\}$，$L_u$是递归可枚举语言但不是递归语言；
- Rice定理：任何非平凡的递归可枚举语言的性质都是不可判定的（“非平凡”指存在图灵机满足该性质，也存在不满足的）；
- Post对应问题（PCP）：给定一组字符串对$(x_1,y_1),...,(x_k,y_k)$，是否存在序列$i_1,...,i_m$使得$x_{i_1}...x_{i_m} = y_{i_1}...y_{i_m}$，PCP是不可判定问题。

#### （2）计算复杂性
- 时间复杂度：图灵机（或非确定图灵机）接受输入串$w$所需的最大步数，记为$T(|w|)$；
- 复杂性类：
  - $P$类：存在多项式时间确定性图灵机判定的语言集合（多项式时间可解问题）；
  - $NP$类：存在多项式时间非确定性图灵机接受的语言集合（多项式时间可验证问题）；
  - $NP$难：所有$NP$问题可多项式时间归约到该问题；
  - $NP$完全：既是$NP$问题又是$NP$难问题；
- 核心结论：$P \subseteq NP$，但$P = NP$是否成立是未解决的千禧年难题；SAT问题（布尔可满足性问题）是第一个被证明的$NP$完全问题。

### 2. 典型题目
- 可判定性判断：利用Rice定理、对角语言、Post对应问题等，判断某问题是否可判定；
- 复杂性类概念：理解$P$、$NP$、$NP$完全的定义和关系，识别典型的$NP$完全问题。

## 总结：语言模型的计算能力对比
按计算能力从弱到强排序：
$\text{正规语言（RE/FA/3型文法）} \subset \text{确定型上下文无关语言（DPDA）} \subset \text{上下文无关语言（PDA/CFG/2型文法）} \subset \text{上下文有关语言（1型文法）} \subset \text{递归可枚举语言（0型文法/图灵机）}$

其中：
- 正规语言：对应FA、RE、3型文法；
- 上下文无关语言：对应PDA、CFG、2型文法；
- 递归可枚举语言：对应图灵机、0型文法。