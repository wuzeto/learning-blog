<script>

window.MathJax = {

  tex: {

    inlineMath: [['$', '$'], ['\\(', '\\)']],

    displayMath: [['$$', '$$'], ['\\[', '\\]']],

    macros: {

      oiint: "{\\mathchoice{\\mkern-18mu\\iint}{\\mkern-12mu\\iint}{\\mkern-13mu\\iint}{\\mkern-12mu\\iint}}"

    }

  }

};

</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>





# 一、操作系统概述







## 1.1 操作系统目标与特征







### 操作系统目标







**四大目标**：



1. **有效性**：提高系统资源利用率，提高系统吞吐量



2. **方便性**：提供友好的用户接口



3. **可扩展性**（2023）：便于修改和增加新功能



4. **开放性**（2023）：遵循国际标准，支持异构系统







### 操作系统基本特征







**四大特征**：



1. **并发性**：多个事件在同一时间间隔内发生



2. **共享性**：资源供多个并发进程共同使用



    * 互斥共享：如打印机



    * 同时访问：如磁盘文件



3. **虚拟性**：将一个物理实体变为多个逻辑对应物



    * 时分复用：如虚拟处理器



    * 空分复用：如虚拟存储器



4. **异步性**：进程以不可预知的速度向前推进







**微内核 vs 宏内核**（2023）：



* **宏内核**：所有OS功能都在内核态运行



* **微内核**：仅最基本功能在内核，其他在用户态







### 局部性原理与程序性能







**局部性原理**：



* **时间局部性**（2012）：被访问的存储单元很可能很快再被访问



* **空间局部性**：被访问存储单元的邻近单元很可能很快被访问







**应用**：



* Cache设计：利用空间局部性预取



* 虚拟存储：利用时间局部性保留常用页



* 磁盘调度：利用空间局部性优化访问







**系统性能指标**：



* **CPU利用率**（2022）：$U_{CPU} = \frac{\text{CPU有效工作时间}}{\text{总时间}}$



* **系统吞吐量**（2017）：单位时间完成作业数



* **系统开销**（2017）：OS运行本身消耗的资源







# 二、进程管理







## 2.1 进程与线程







### 进程概念与特征







**进程定义**：程序的一次执行过程，是系统资源分配和调度的基本单位







**进程特征**：



1. **动态性**：有生命周期（创建→执行→终止）



2. **并发性**：多个进程可同时执行



3. **独立性**：独立获得资源和调度



4. **异步性**：以不可预知速度推进



5. **结构性**：由程序段、数据段、PCB组成







**进程控制块（PCB）**：



* **进程描述信息**：PID、UID等



* **进程控制信息**：状态、优先级、程序计数器等



* **资源信息**：打开文件、内存分配等



* **CPU现场信息**：寄存器值等







### 进程状态模型







**三状态模型**：



* **就绪态**：已获资源，只等CPU



* **运行态**：正在CPU上执行



* **阻塞态**：等待某事件（如I/O完成）







**五状态模型**：



* 增加**新建态**：进程正在创建



* 增加**终止态**：进程已结束，等待善后







**七状态模型**：



* 增加**挂起就绪**：进程被换出到外存，但就绪



* 增加**挂起阻塞**：进程被换出到外存，且阻塞







### 线程与多线程模型







**线程定义**：进程内的执行单元，是CPU调度的基本单位







**线程 vs 进程**：



| 特性 | 进程 | 线程 |



|------|------|------|



| 资源拥有 | 拥有资源的基本单位 | 不拥有系统资源 |



| 调度 | 资源分配的基本单位 | CPU调度的基本单位 |



| 并发性 | 进程间并发 | 线程间并发 |



| 系统开销 | 大（创建、撤销、切换） | 小 |



| 通信 | 复杂（IPC） | 简单（共享内存） |







**多线程模型**：



1. **多对一模型**（2011）：多个用户线程映射到一个内核线程



2. **一对一模型**（2011）：每个用户线程映射到一个内核线程



3. **多对多模型**（2011）：多个用户线程映射到多个内核线程







**线程实现**：



* **用户级线程**（2012）：由用户库实现，内核无感知



* **内核级线程**（2012）：由内核支持，调度开销大







## 2.2 进程同步与互斥







### 同步与互斥基本概念







**临界资源**（2016）：一次仅允许一个进程使用的资源







**临界区**（2010）：访问临界资源的代码段







**同步机制四准则**（Peterson算法，2018）：



1. **空闲让进**：无进程在临界区时应允许进入



2. **忙则等待**：已有进程在临界区时应等待



3. **有限等待**：等待时间应有限



4. **让权等待**（2016）：不能进入时应释放CPU







**实现方法**：



* **软件方法**：Peterson算法（2018）



* **硬件方法**：TestAndSet指令（2018），Swap指令（2018）



* **信号量方法**：PV操作







### 信号量与PV操作（2011）







**信号量定义**：整型变量，表示可用资源数







**P操作（wait）**：



1. 信号量值减1



2. 如果值小于0，阻塞当前进程并加入等待队列







**V操作（signal）**：



1. 信号量值加1



2. 如果值小于等于0，从等待队列唤醒一个进程







**信号量类型**：



* **整型信号量**：不满足让权等待



* **记录型信号量**：增加等待队列







### 经典同步问题







**1. 生产者-消费者问题（2014）**：



* 互斥信号量：mutex = 1



* 资源信号量：empty = n（空缓冲区数），full = 0（满缓冲区数）



* 生产者流程：P(empty)→P(mutex)→生产→V(mutex)→V(full)



* 消费者流程：P(full)→P(mutex)→消费→V(mutex)→V(empty)







**2. 读者-写者问题**：



* 读写互斥信号量：rw_mutex = 1



* 读者计数保护：mutex = 1



* 读者流程：先保护计数，第一个读者锁rw_mutex，读完后最后一个读者解锁



* 写者流程：直接锁rw_mutex，写完后解锁







**3. 哲学家进餐问题（2019）**：



* 解决方法：限制最多4人同时拿筷子



* 信号量：limit = 4，chopstick[5] = {1,1,1,1,1}



* 流程：P(limit)→P(chopstick[i])→P(chopstick[(i+1)%5])→进餐→释放筷子→V(limit)







**4. 管程（Monitor，2016）**：



* 封装共享数据和操作过程



* 条件变量：wait，signal操作



* 保证互斥访问，简化编程







### 进程通信







**管道（Pipe，2014）**：



* 半双工通信



* 只能用于父子进程或兄弟进程



* 管道文件：pipefs文件系统







**消息队列**：



* 消息的链表，有类型



* 支持随机查询，非先进先出







**共享内存**：



* 最快IPC方式



* 需要同步机制配合







**信号量**：见前面







**套接字**：网络通信







## 2.3 处理机调度







### 调度层次与算法







**三级调度**：



1. **高级调度（作业调度）**：从外存调入作业



2. **中级调度（内存调度）**：内外存交换



3. **低级调度（进程调度）**：分配CPU







**调度算法分类**：



* **非抢占式**（2011）：进程主动放弃CPU



* **抢占式**（2019）：OS强制收回CPU







### 单处理器调度算法







**1. 先来先服务（FCFS，2009）**：



* 按到达顺序服务



* 优点：简单公平



* 缺点：平均等待时间长，对短作业不利







**2. 短进程优先（SPN，2009）**：



* 选择估计运行时间最短的进程



* 抢占式版本：最短剩余时间优先（SRT）



* 优点：平均等待时间最短



* 缺点：长作业可能饥饿







**3. 时间片轮转（RR，2009）**：



* 每个进程分配一个时间片



* 时间片选择：10-100ms



* 优点：响应快，公平



* 缺点：上下文切换开销大







**4. 高响应比优先（HRRN，2009）**：



$\text{响应比} = \frac{\text{等待时间} + \text{要求服务时间}}{\text{要求服务时间}}$







**5. 多级反馈队列（Feedback，2019）**：



1. 设置多个队列，优先级递减，时间片递增



2. 新进程进入最高优先级队列



3. 执行完时间片未结束，降入下一级队列



4. 高优先级队列不为空时，不执行低优先级队列



5. 最后一级队列采用RR调度







**思想**：综合多种调度算法优点



**复杂度**：$O(n)$







**6. 优先级调度**：



* **静态优先级**（2016）：创建时确定，不变



* **动态优先级**（2016）：运行时调整



* **nice值**（2016）：Unix/Linux中的优先级调整







**7. 公平共享调度**：



* 按组分配CPU时间



* 防止单个用户垄断CPU







**调度算法比较**：



| 算法 | 抢占性 | 平均等待时间 | 响应时间 | 特点 |



|------|--------|--------------|----------|------|



| FCFS | 非抢占 | 最长 | 长 | 简单公平 |



| SJF | 可选 | 最短 | 不定 | 长作业饥饿 |



| RR | 抢占 | 中等 | 短 | 公平响应快 |



| 优先级 | 可选 | 不定 | 不定 | 可能饥饿 |



| 多级反馈 | 抢占 | 较好 | 较好 | 综合性能好 |







## 2.4 死锁处理







### 死锁概念与条件







**死锁定义**：多个进程因竞争资源而无限等待







**死锁必要条件**（2009）：



1. **互斥条件**：资源排他性使用



2. **请求和保持条件**（2013）：已持有资源又请求新资源



3. **不剥夺条件**：资源只能自愿释放



4. **循环等待条件**：进程间形成等待环







**资源分配图**：



* 圆形：进程



* 矩形：资源类，圆点：资源实例



* 请求边：进程→资源



* 分配边：资源→进程



* 死锁检测：图中有环路且资源单实例







### 死锁处理策略







**1. 死锁预防**：破坏必要条件



* 破坏互斥：不可能（某些资源必须互斥）



* 破坏请求和保持：一次性申请所有资源



* 破坏不剥夺：允许抢夺资源



* 破坏循环等待：按顺序申请资源







**2. 死锁避免**（2015）：



* **银行家算法**（2013）：



    1. 检查请求是否超过需求



    2. 检查请求是否超过可用资源



    3. 试探性分配资源



    4. 执行安全性检查



    5. 如果安全则分配，否则恢复







**思想**：分配前检查系统是否安全



**复杂度**：$O(m \times n^2)$，$m$资源数，$n$进程数







**3. 死锁检测**（2015）：



* 定期检测资源分配图



* **死锁定理**：S状态死锁的充要条件是资源分配图不可完全简化







**4. 死锁解除**：



* 资源剥夺：从某些进程剥夺资源



* 撤销进程：撤销部分或全部死锁进程



* 进程回退：回退到安全状态



# 六、历年真题考点



## 6.1 2009-2013年



### 2009



**核心考点**：

1. **单处理机调度**：RR、SPN、FCFS、HRRN算法

2. **分段存储**：段号、段长、随机访问特性

3. **索引结构**：文件索引分配方式

4. **磁盘调度SCAN**：电梯算法实现

5. **文件控制块FCB**：文件管理核心数据结构

6. **信号量与LRU**：同步机制和页面置换



**易错点**：HRRN响应比计算，SCAN算法方向判断



### 2010



**核心考点**：

1. **请求分页**：缺页中断处理流程

2. **二级页表**：页目录、页表项结构

3. **磁盘C-SCAN**：循环扫描算法

4. **CLOCK算法**：改进的页面置换

5. **逻辑地址空间**：地址映射基础



**易错点**：二级页表地址计算，C-SCAN返回方式



### 2011



**核心考点**：

1. **多线程模型**：多对一、一对一、多对多

2. **抖动与交换区**：虚拟存储性能问题

3. **PV操作**：wait、signal原语

4. **连续存储**：文件分配方式

5. **地址变换机构**：MMU工作原理



**易错点**：PV操作顺序，抖动产生条件



### 2012



**核心考点**：

1. **时间局部性**：程序访问特性

2. **用户级线程**：线程实现方式

3. **空闲页框链**：页面缓冲管理

4. **预读与滞后写**：磁盘优化技术



**易错点**：时间局部性与空间局部性区别



### 2013



**核心考点**：

1. **银行家算法**：死锁避免算法

2. **多级索引**：大文件存储方式

3. **i-node结构**：UNIX文件系统核心

4. **请求和保持**：死锁必要条件



**易错点**：银行家算法安全性检查，索引计算



## 6.2 2014-2018年



### 2014



**核心考点**：

1. **Belady异常**：FIFO算法特有现象

2. **位图法**：磁盘空间管理

3. **管道通信**：进程间通信方式

4. **生产者消费者**：经典同步问题



**易错点**：Belady异常条件，位图大小计算



### 2015



**核心考点**：

1. **直接/间接索引**：文件指针类型

2. **可变/固定分配**：内存分配策略

3. **全局/局部置换**：页面置换范围



**易错点**：索引指针级数计算



### 2016



**核心考点**：

1. **工作集模型**：防止抖动方法

2. **SPOOLing**：假脱机技术

3. **FAT文件系统**：文件分配表

4. **让权等待**：同步机制准则



**易错点**：工作集窗口选择，FAT表项含义



### 2017



**核心考点**：

1. **文件权限**：用户类别和访问控制

2. **文件描述符**：打开文件标识

3. **i-node内存常驻**：性能优化



**易错点**：权限位计算，文件描述符管理



### 2018



**核心考点**：

1. **Peterson算法**：软件同步方法

2. **TestAndSet**：硬件同步指令

3. **磁盘高速缓存**：性能优化技术



**易错点**：Peterson算法理解，TSL指令原子性



## 6.3 2019-2025年



### 2019



**核心考点**：

1. **二级反馈队列**：多级调度算法

2. **内存分配算法**：FF、NF、BF、WF

3. **哲学家进餐**：同步问题解决



**易错点**：反馈队列优先级，内存碎片类型



### 2020



**核心考点**：

1. **中断向量表**：中断处理基础

2. **临界区互斥**：同步机制实现



**易错点**：中断向量表结构



### 2021-2025新趋势



**核心考点**：

1. **改进CLOCK算法**：考虑访问位和修改位

2. **多阶段引导**（2021）：系统启动过程

3. **宏/微内核**（2023）：内核架构选择

4. **主动出让CPU**（2023）：协作式调度

5. **内存映射文件**（2025）：文件访问优化

6. **VFS虚拟文件系统**（2025）：统一文件接口



**备考重点**：新技术在传统理论中的应用



---



**操作系统复习指南：理论理解 → 算法掌握 → 系统设计 → 问题分析**



**核心能力：并发控制 + 资源管理 + 系统优化 + 故障处理**